; A dcpu16 program that rewrites another dcpu16 program, allowing the
; child program to be executed without compromising the system,
; but at a performance and memory cost
;
; Works by first checking for illegal instructions (IAQ, IAS, IAG, HWI, or unrecognized instructions)
;     - To prevent abuse of undocumented instructions, any invalid dcpu16 instructions are considered illegal
; Then the child program is rewritten as follows:
;     - Any instructions that set PC to an unknown value will be replaced with a JSR to bounds-check at runtime
;     - Any instructions that set Ram at an unknown address will be replaced with a JSR to bounds-check at runtime
;     - Any instructions that set PC or Ram will be subject to a bounds check and may be considered an illegal instruction
;     - Any instructions that modify SP will be replaced/emulated, as the actual SP register is used by the this program
;     - Using the stack is considered to be accessing Ram at an unknown address
;     - INT calls are considered to be calls to standard functions provided by this program
;         * Any unrecognized std function calls are considered to be illegal instructions
;         * By default, no std function calls are provided, thus all INT instructions will be illegal
;         * INT calls can not use short literals
;     - The last instruction in code space is considered to be the end of the program, and will be replaced with a JSR to ensure this
;     - If this program can not acquire an interrupt handler for a short literal INT
;         * Any 1 words instructions that need replaced will be considered illegal
;
; The child program will NOT be altered to work with cooperative multitasking systems
; (cooperative multitasking is risky, the replaced instruction handler can be altered to coop,
;            and std coop functions could be provided to the child, but nothing will force the child to use them)

; TODO: make sure any changes to PC land on a verified instruction (Note: may have to consider instructions that SET PC to an unknown value to be illegal)
;       example:
;          IN_YOUR_BASE:
;              SET A, <illegal instruction>
;              SET PC, POP
;              <more code>
;              SET PC, IN_YOUR_BASE+1
; TODO: I said above I would only replace instructions that I can't bounds check at program load. Actually do this.
; TODO: Allow (optional?) bounds-checking on ram reads
;               Originally written to allow file system drivers to be loaded from the floppy with the fs in question
;               However, as it currently stands, reading from ram is not bounds checked
;               It would be possible in the described scenerio to dump the ram to disk, potentially exposing private data
; TODO: consider self-modifying code or some other way of using the dcpu16 to execute instructions in the handlers

.include "db.dasm"

short_replace:
    INT 0x1E

init:
    ;This function should be called once, ever (NOT once per program rewritten/loaded)
    ;Register things with the OS here
    SET PC, POP

op_table:   ;0 -- invalid, 1 -- replace, 2 -- valid provided operands are valid
    DAT 2   ;Extended ops
    DAT 2   ;SET
    DAT 2   ;ADD
    DAT 2   ;SUB
    DAT 2   ;MUL
    DAT 2   ;MLI
    DAT 2   ;DIV
    DAT 2   ;DVI
    DAT 2   ;MOD
    DAT 2   ;MDI
    DAT 2   ;AND
    DAT 2   ;BOR
    DAT 2   ;XOR
    DAT 2   ;SHR
    DAT 2   ;ASR
    DAT 2   ;SHL
    DAT 2   ;IFB
    DAT 2   ;IFC
    DAT 2   ;IFE
    DAT 2   ;IFN
    DAT 2   ;IFG
    DAT 2   ;IFA
    DAT 2   ;IFL
    DAT 2   ;IFU
    DAT 0
    DAT 0
    DAT 2   ;ADX
    DAT 2   ;SBX
    DAT 0
    DAT 0
    DAT 2   ;STI
    DAT 2   ;STD

ext_op_table:   ;0 -- invalid, 1 -- replace, 2 -- valid provided operands are valid
    DAT 0   ;Reserved
    DAT 1   ;JSR
    DAT 0
    DAT 0
    DAT 0
    DAT 0
    DAT 0
    DAT 0
    DAT 1   ;INT
    DAT 0   ;IAG
    DAT 0   ;IAS
    DAT 1   ;RFI
    DAT 0   ;IAQ
    DAT 0
    DAT 0
    DAT 0
    DAT 0   ;HWN    ;warning, should you chose to allow HWN, HWN sets a, which kinda messes up the operand_table
    DAT 0   ;HWQ
    DAT 0   ;HWI
    DAT 0
    DAT 0
    DAT 0
    DAT 0
    DAT 0
    DAT 0
    DAT 0
    DAT 0
    DAT 0
    DAT 0
    DAT 0
    DAT 0
    DAT 0

operand_table:   ;0 -- replace, 1 -- replace if b (valid as a), 2 -- replace if a (valid as b), 3 -- valid
    DAT 3   ;A
    DAT 3   ;B
    DAT 3   ;C
    DAT 3   ;X
    DAT 3   ;Y
    DAT 3   ;Z
    DAT 3   ;I
    DAT 3   ;J
    DAT 1   ;[A]
    DAT 1   ;[B]
    DAT 1   ;[C]
    DAT 1   ;[X]
    DAT 1   ;[Y]
    DAT 1   ;[Z]
    DAT 1   ;[I]
    DAT 1   ;[J]
    DAT 1   ;[A+x]
    DAT 1   ;[B+x]
    DAT 1   ;[C+x]
    DAT 1   ;[X+x]
    DAT 1   ;[Y+x]
    DAT 1   ;[Z+x]
    DAT 1   ;[I+x]
    DAT 1   ;[J+x]
    DAT 0   ;PUSH/POP   ;SP is emulated (we use the SP register for other things)    
    DAT 0   ;PEEK       ;SP is emulated
    DAT 0   ;PICK       ;SP is emulated
    DAT 0   ;SP         ;SP is emulated
    DAT 1   ;PC
    DAT 3   ;EX
    DAT 1   ;[next word]
    DAT 3   ;next word (literal)
    ;Anything above is a literal(3/valid), code that uses this table should check for literals first

rewrite:
    ;Get address of program
    ;Get length of program
    ;Get length of code
    
    ;Add prog id to database
    SET PUSH, <code_start>  ;TODO   ;[SP-3]
    SET PUSH, <code_end>            ;[SP-2]
    SET PUSH, <data_start>          ;[SP-1]
    SET PUSH, <data_end>            ;[SP]
    JSR add_prog_id     ;Store program in database, and get prog_id
    ADD SP, 4
    IFE A, 0
        JMP insufficent_space
    SET PUSH, A ;Save prog_id in stack, because most future function calls will need it anyways
        
    ;Loop through code
    SET I, [SP-3]
_loop:
        ;Pull out op<x>, b<B> from instruction
        SET X, [I]
        AND X, 0x1F
        SET B, [I]
        SHR B, 5
        AND B, 0x1F
        SET A, [I]
        SHR A, 10
        AND A, 0x3F
        
        ;If op is 0
        IFE X, 0
            JMP _op_0
        JMP _op_not_0
        
        _op_0:
            SET B, [ext_op_table+B]
            IFE B, 0
                JMP illegal_instruction
            ;if last instruction
                JMP _last_instruction
            IFE B, 1
                JMP _replace_instruction
            IFE B, 2
                JMP _continue
            
            JMP illegal_instruction
        
    _op_not_0:
        SET X, [op_table+X]
        IFE X, 0
            JMP illegal_instruction
        ;if last instruction
            JMP _last_instruction
        IFE X, 1
            JMP _replace_instruction
        IFE X, 2
            JMP _continue
        
        JMP illegal_instruction
    
    _last_instruction:
        JSR db_add (args: address of instruction, prog_id, instruction0, instruction1, instruction2)
        ;replace with JSR last_instruction_handler
        JMP _continue
    _replace_instruction:
        ;NOTE: 3 word instructions should be replaced with an extra SET A, A instruction appended to compenstate for size
        JSR db_add (args: address of instruction, prog_id, instruction0, instruction1, instruction2)
        ;replace with JSR dangerous_instruction_handler
_continue:
    JMP _loop
    
    SET PC, POP
    

insufficent_space:
    ;Maybe print different error message
    ;Do the rest of illegal_instruction
illegal_instruction_runtime:
    ;Maybe print different error message
    ;Do the rest of illegal_instruction
illegal_instruction:
    ;Maybe print error message
    ;Return error code
    SUB PC, 1

last_instruction_handler:
    ;Get original instruction data
    ;if op is 0
        ;if b is INT
            ;Get a
            ;Lookup std function
            ;Restore state
            ;JSR <std_function>
    ;if b is PC
        ;invoke dangerous_instruction_handler
    ;if b is a stack op
        ;invoke dangerous_instruction_handler
    ;if b is a ram write
        ;invoke dangerous_instruction_handler
    ;if nothing above
        ;exec instruction
    ;abort child program
    
dangerous_instruction_handler:
    ;Save state
    ;Get original instruction data
    JSR db_lookup (args: [SP] before this instruction) (provides prog_id, instruction0, instruction1, instruction2)
    ;get a
    ;resolve/emulate a
    ;get op
    ;if b is PC
        ;change op to SET, changing a to keep the behavior identical
        ;get prog_id
        ;get code bounds
        JSR prog_get_code_bounds (args: prog_id)
        ;If a not in code bounds
            JMP illegal_instruction_runtime
        ;check for illegal instructions at a, and the 2 words after (or less if near edge of code)
        ;If illegal instructions
            JMP illegal_instruction_runtime
        ;Restore state
        ;Set PC to a
    ;if b is a stack operation or a ram write
        ;Resolve b to an address
        JSR prog_get_data_bounds (args: prog_id)
        ;if b not in data bounds
            JMP illegal_instruction_runtime
        ;Get a
        ;Resolve a
        ;SET [b], a
    ;Restore state
    ;SET PC to next instruction

;Function lookup table
;Functions expect
;   A    - pointer to value of A
;   B    - pointer to value of B
;   [SP] - Return address
emu_op_table:
    DAT 0   ;Extended ops
    DAT emu_SET
    DAT emu_ADD
    DAT emu_SUB
    DAT emu_MUL
    DAT emu_MLI
    DAT emu_DIV
    DAT emu_DVI
    DAT emu_MOD
    DAT emu_MDI
    DAT emu_AND
    DAT emu_BOR
    DAT emu_XOR
    DAT emu_SHR
    DAT emu_ASR
    DAT emu_SHL
    DAT emu_IFB
    DAT emu_IFC
    DAT emu_IFE
    DAT emu_IFN
    DAT emu_IFG
    DAT emu_IFA
    DAT emu_IFL
    DAT emu_IFU
    DAT emu_NOP
    DAT emu_NOP
    DAT emu_ADX
    DAT emu_SBX
    DAT emu_NOP
    DAT emu_NOP
    DAT emu_STI
    DAT emu_STD

emu_NOP:
    SET PC, POP

emu_SET:
    ;check bounds of B
    ;set B to A
    SET PC, POP

emu_ADD:
    SET PUSH, [B]
    ADD PEEK, [A]
    ;PUT EX IN EX
    SET A, SP
    SET EX, POP
    JMP emu_SET

emu_SUB:
    SET PUSH, [B]
    SUB PEEK, [A]
    ;PUT EX IN EX
    SET A, SP
    SET EX, POP
    JMP emu_SET

emu_MUL:
    SET PUSH, [B]
    MUL PEEK, [A]
    ;PUT EX IN EX
    SET A, SP
    SET EX, POP
    JMP emu_SET

emu_MLI:
    SET PUSH, [B]
    MLI PEEK, [A]
    ;PUT EX IN EX
    SET A, SP
    SET EX, POP
    JMP emu_SET

emu_DIV:
    SET PUSH, [B]
    DIV PEEK, [A]
    ;PUT EX IN EX
    SET A, SP
    SET EX, POP
    JMP emu_SET

emu_DVI:
    SET PUSH, [B]
    DVI PEEK, [A]
    ;PUT EX IN EX
    SET A, SP
    SET EX, POP
    JMP emu_SET

emu_MOD:
    SET PUSH, [B]
    MOD PEEK, [A]
    SET A, SP
    SET EX, POP
    JMP emu_SET

emu_MDI:
    SET PUSH, [B]
    MDI PEEK, [A]
    SET A, SP
    SET EX, POP
    JMP emu_SET

emu_AND:
    SET PUSH, [B]
    AND PEEK, [A]
    SET A, SP
    SET EX, POP
    JMP emu_SET

emu_BOR:
    SET PUSH, [B]
    BOR PEEK, [A]
    SET A, SP
    SET EX, POP
    JMP emu_SET

emu_XOR:
    SET PUSH, [B]
    XOR PEEK, [A]
    SET A, SP
    SET EX, POP
    JMP emu_SET

emu_SHR:
    SET PUSH, [B]
    SHR PEEK, [A]
    SET A, SP
    SET EX, POP
    JMP emu_SET

emu_ASR:
    SET PUSH, [B]
    ASR PEEK, [A]
    SET A, SP
    SET EX, POP
    JMP emu_SET

emu_SHL:
    SET PUSH, [B]
    XOR PEEK, [A]
    SET A, SP
    SET EX, POP
    JMP emu_SET

emu_IFB:
    IFC [B], [A]
        ;Move next address forward
    SET PC, POP

emu_IFC:
    IFB [B], [A]
        ;Move next address forward
    SET PC, POP

emu_IFE:
    IFN [B], [A]
        ;Move next address forward
    SET PC, POP

emu_IFN:
    IFE [B], [A]
        ;Move next address forward
    SET PC, POP

emu_IFG:
    IFG [B], [A]
        SET PC, POP
    ;Move next address forward
    SET PC, POP

emu_IFA:
    IFA [B], [A]
        SET PC, POP
    ;Move next address forward
    SET PC, POP

emu_IFL:
    IFL [B], [A]
        SET PC, POP
    ;Move next address forward
    SET PC, POP

emu_IFU:
    IFU [B], [A]
        SET PC, POP
    ;Move next address forward
    SET PC, POP

emu_ADX:
    SET PUSH, [B]
    ;Restore app's EX
    ADX PEEK, [A]
    ;Store app's EX
    SET A, SP
    SET EX, POP
    JMP emu_SET

emu_SBX:
    SET PUSH, [B]
    ;Restore app's EX
    ABX PEEK, [A]
    ;Store app's EX
    SET A, SP
    SET EX, POP
    JMP emu_SET

emu_STI:    ;TODO: consider copying SET for performace
    JSR emu_SET
    ;Increase app's I by 1
    ;Increase app's J by 1
    SET PC, POP

emu_SBX:    ;TODO: consider copying SET for performace
    JSR emu_SET
    ;Decrease app's I by 1
    ;Decrease app's J by 1
    SET PC, POP