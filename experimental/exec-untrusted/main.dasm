; A dcpu16 program that rewrites another dcpu16 program, allowing the
; child program to be executed without compromising the system,
; but at a performance and memory cost
;
; Works by first checking for illegal instructions (IAQ, IAS, IAG, HWI, or unrecognized instructions)
;     - To prevent abuse of undocumented instructions, any invalid dcpu16 instructions are considered illegal
; Then the child program is rewritten as follows:
;     - Any instructions that set PC to an unknown value will be replaced with a JSR to bounds-check at runtime
;     - Any instructions that set Ram at an unknown address will be replaced with a JSR to bounds-check at runtime
;     - Any instructions that set PC or Ram will be subject to a bounds check and may be considered an illegal instruction
;     - Any instructions that modify SP will be replaced/emulated, as the actual SP register is used by the this program
;     - Using the stack is considered to be accessing Ram at an unknown address
;     - INT calls are considered to be calls to standard functions provided by this program
;         * Any unrecognized std function calls are considered to be illegal instructions
;         * By default, no std function calls are provided, thus all INT instructions will be illegal
;         * INT calls can not use short literals
;     - The last instruction in code space is considered to be the end of the program, and will be replaced with a JSR to ensure this
;     - If this program can not acquire an interrupt handler for a short literal INT
;         * Any 1 words instructions that need replaced will be considered illegal
;
; The child program will NOT be altered to work with cooperative multitasking systems
; (cooperative multitasking is risky, the replaced instruction handler can be altered to coop,
;            and std coop functions could be provided to the child, but nothing will force the child to use them)

; TODO: make sure any changes to PC land on a verified instruction (Note: may have to consider instructions that SET PC to an unknown value to be illegal)
;       example:
;          IN_YOUR_BASE:
;              SET A, <illegal instruction>
;              SET PC, POP
;              <more code>
;              SET PC, IN_YOUR_BASE+1
; TODO: I said above I would only replace instructions that I can't bounds check at program load. Actually do this.
; TODO: Allow (optional?) bounds-checking on ram reads
;               Originally written to allow file system drivers to be loaded from the floppy with the fs in question
;               However, as it currently stands, reading from ram is not bounds checked
;               It would be possible in the described scenerio to dump the ram to disk, potentially exposing private data
; TODO: consider self-modifying code or some other way of using the dcpu16 to execute instructions in the handlers

.include "db.dasm"

short_replace:
    INT 0x1E

init:
    ;This function should be called once, ever (NOT once per program rewritten/loaded)
    ;Register things with the OS here
    SET PC, POP

rewrite:
    ;Get address of program
    ;Get length of program
    ;Get length of code
    
    ;Add prog id to database
    SET PUSH, <code_start>  ;TODO   ;[SP-3]
    SET PUSH, <code_end>            ;[SP-2]
    SET PUSH, <data_start>          ;[SP-1]
    SET PUSH, <data_end>            ;[SP]
    JSR add_prog_id     ;Store program in database, and get prog_id
    IFE A, 0
        JMP insufficent_space
    SET PEEK, A ;Save prog_id in stack, because most future function calls will need it anyways
        
    ;Loop through code
    SET I, [SP-3]
_loop:
        ;Pull out op<x>, b<B> from instruction
        SET X, [I]
        AND X, 0x1F
        SET B, [I]
        SHR B, 5
        AND B, 0x1F
        SET A, [I]
        SHR A, 10
        AND A, 0x3F
        
        ;If op is 0
        IFE X, 0
            JMP _op_0
        JMP _op_not_0
        
        _op_0:
            ;If b is illegal (IAQ, IAS, IAG, RFI, HWI, HWN, HWQ, any invalid dcpu16 instructions)
            IFN B, 0x08     ;B != INT
                IFN B, 0x01     ;B != JSR
                    JMP illegal_instruction
            
            ;If b is JSR
            IFE B, 0x01     ;B == JSR
                JSR db_add (args: address of instruction, prog_id, instruction0, instruction1, instruction2)
                ;replace with JSR dangerous_instruction_handler
            
            IFN B, 0x08     ;B != INT
                JMP _continue
                
            ;If a is short
            IFN A, 0x10
            IFN A, 0x11
            IFN A, 0x12
            IFN A, 0x13
            IFN A, 0x14
            IFN A, 0x15
            IFN A, 0x16
            IFN A, 0x17
            IFN A, 0x1a
            IFN A, 0x1e
            IFN A, 0x1f
                JMP illegal_instruction ;TODO: handle shorter instructions
            
            SET PUSH, I
            JSR db_add (args: prog_id, address of instruction)
            SET A, POP
            SET [I], [PC++]
                JSR dangerous_instruction_handler
            JMP _continue
            
            ;Lookup std function
            ;If lookup failed
                ;JMP illegal_instruction
            ;if last instruction
                JSR db_add (args: address of instruction, prog_id, instruction0, instruction1, instruction2)
                ;replace with JSR last_instruction_handler
            ;replace with JSR <std_function>
        
    _op_not_0:
        
        ;if op is an invalid dcpu16 instruction
        IFE X, 0x18
            JMP illegal_instruction
        IFE X, 0x19
            JMP illegal_instruction
        IFE X, 0x1a
            JMP illegal_instruction
        IFE X, 0x1b
            JMP illegal_instruction
        
        ;if last instruction
            JSR db_add (args: address of instruction, prog_id, instruction0, instruction1, instruction2)
            ;replace with JSR last_instruction_handler
        ;if op is an IF* instruction
            ;continue
        
        ;NOTE: 3 word instructions should be replaced with an extra SET A, A instruction appended to compenstate for size
        ;if b is a stack operation, or SP
            JSR db_add (args: address of instruction, prog_id, instruction0, instruction1, instruction2)
            ;replace with JSR dangerous_instruction_handler
        ;if a is a stack operation, or SP
            JSR db_add (args: address of instruction, prog_id, instruction0, instruction1, instruction2)
            ;replace with JSR dangerous_instruction_handler
        ;if op is an IF* instruction
            ;continue
        ;if b is PC
            JSR db_add (args: address of instruction, prog_id, instruction0, instruction1, instruction2)
            ;replace with JSR dangerous_instruction_handler
        ;if b is a ram write
            JSR db_add (args: address of instruction, prog_id, instruction0, instruction1, instruction2)
            ;replace with JSR dangerous_instruction_handler
_continue:
    JMP _loop
    
    SET PC, POP
    

insufficent_space:
    ;Maybe print different error message
    ;Do the rest of illegal_instruction
illegal_instruction_runtime:
    ;Maybe print different error message
    ;Do the rest of illegal_instruction
illegal_instruction:
    ;Maybe print error message
    ;Return error code
    SUB PC, 1

last_instruction_handler:
    ;Get original instruction data
    ;if op is 0
        ;if b is INT
            ;Get a
            ;Lookup std function
            ;Restore state
            ;JSR <std_function>
    ;if b is PC
        ;invoke dangerous_instruction_handler
    ;if b is a stack op
        ;invoke dangerous_instruction_handler
    ;if b is a ram write
        ;invoke dangerous_instruction_handler
    ;if nothing above
        ;exec instruction
    ;abort child program
        
dangerous_instruction_handler:
    ;Get original instruction data
    JSR db_lookup (args: [SP] before this instruction) (provides prog_id, instruction0, instruction1, instruction2)
    ;get a
    ;resolve/emulate a
    ;get op
    ;if b is PC
        ;change op to SET, changing a to keep the behavior identical
        ;get prog_id
        ;get code bounds
        JSR prog_get_code_bounds (args: prog_id)
        ;If a not in code bounds
            JMP illegal_instruction_runtime
        ;check for illegal instructions at a, and the 2 words after (or less if near edge of code)
        ;If illegal instructions
            JMP illegal_instruction_runtime
        ;Restore state
        ;Set PC to a
    ;if b is a stack operation or a ram write
        ;Resolve b to an address
        JSR prog_get_data_bounds (args: prog_id)
        ;if b not in data bounds
            JMP illegal_instruction_runtime
        ;Get a
        ;Resolve a
        ;SET [b], a
    ;Restore state
    ;SET PC to next instruction
